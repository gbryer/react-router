{"version":3,"file":"react-router.min.js","sources":["../modules/RouterContext.js","../modules/Router.js","../modules/MemoryRouter.js","../modules/Lifecycle.js","../modules/Prompt.js","../modules/generatePath.js","../modules/Redirect.js","../modules/matchPath.js","../modules/Route.js","../modules/StaticRouter.js","../modules/Switch.js","../modules/withRouter.js"],"sourcesContent":["// TODO: Replace with React.createContext once we can assume React 16+\r\nimport createContext from \"mini-create-react-context\";\r\n\r\nconst createNamedContext = name => {\r\n  const context = createContext();\r\n  context.displayName = name;\r\n\r\n  return context;\r\n};\r\n\r\nconst context = /*#__PURE__*/ createNamedContext(\"Router\");\r\nexport default context;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport warning from \"tiny-warning\";\r\n\r\nimport RouterContext from \"./RouterContext\";\r\n\r\n/**\r\n * The public API for putting history on context.\r\n */\r\nclass Router extends React.Component {\r\n  static computeRootMatch(pathname) {\r\n    return { path: \"/\", url: \"/\", params: {}, isExact: pathname === \"/\" };\r\n  }\r\n\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      location: props.history.location\r\n    };\r\n\r\n    // This is a bit of a hack. We have to start listening for location\r\n    // changes here in the constructor in case there are any <Redirect>s\r\n    // on the initial render. If there are, they will replace/push when\r\n    // they mount and since cDM fires in children before parents, we may\r\n    // get a new location before the <Router> is mounted.\r\n    this._isMounted = false;\r\n    this._pendingLocation = null;\r\n\r\n    if (!props.staticContext) {\r\n      this.unlisten = props.history.listen(location => {\r\n        if (this._isMounted) {\r\n          this.setState({ location });\r\n        } else {\r\n          this._pendingLocation = location;\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  componentDidMount() {\r\n    this._isMounted = true;\r\n\r\n    if (this._pendingLocation) {\r\n      this.setState({ location: this._pendingLocation });\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.unlisten) this.unlisten();\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <RouterContext.Provider\r\n        children={this.props.children || null}\r\n        value={{\r\n          history: this.props.history,\r\n          location: this.state.location,\r\n          match: Router.computeRootMatch(this.state.location.pathname),\r\n          staticContext: this.props.staticContext\r\n        }}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\nif (__DEV__) {\r\n  Router.propTypes = {\r\n    children: PropTypes.node,\r\n    history: PropTypes.object.isRequired,\r\n    staticContext: PropTypes.object\r\n  };\r\n\r\n  Router.prototype.componentDidUpdate = function(prevProps) {\r\n    warning(\r\n      prevProps.history === this.props.history,\r\n      \"You cannot change <Router history>\"\r\n    );\r\n  };\r\n}\r\n\r\nexport default Router;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { createMemoryHistory as createHistory } from \"history\";\r\nimport warning from \"tiny-warning\";\r\n\r\nimport Router from \"./Router\";\r\n\r\n/**\r\n * The public API for a <Router> that stores location in memory.\r\n */\r\nclass MemoryRouter extends React.Component {\r\n  history = createHistory(this.props);\r\n\r\n  render() {\r\n    return <Router history={this.history} children={this.props.children} />;\r\n  }\r\n}\r\n\r\nif (__DEV__) {\r\n  MemoryRouter.propTypes = {\r\n    initialEntries: PropTypes.array,\r\n    initialIndex: PropTypes.number,\r\n    getUserConfirmation: PropTypes.func,\r\n    keyLength: PropTypes.number,\r\n    children: PropTypes.node\r\n  };\r\n\r\n  MemoryRouter.prototype.componentDidMount = function() {\r\n    warning(\r\n      !this.props.history,\r\n      \"<MemoryRouter> ignores the history prop. To use a custom history, \" +\r\n        \"use `import { Router }` instead of `import { MemoryRouter as Router }`.\"\r\n    );\r\n  };\r\n}\r\n\r\nexport default MemoryRouter;\r\n","import React from \"react\";\r\n\r\nclass Lifecycle extends React.Component {\r\n  componentDidMount() {\r\n    if (this.props.onMount) this.props.onMount.call(this, this);\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.props.onUnmount) this.props.onUnmount.call(this, this);\r\n  }\r\n\r\n  render() {\r\n    return null;\r\n  }\r\n}\r\n\r\nexport default Lifecycle;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport invariant from \"tiny-invariant\";\r\n\r\nimport Lifecycle from \"./Lifecycle\";\r\nimport RouterContext from \"./RouterContext\";\r\n\r\n/**\r\n * The public API for prompting the user before navigating away from a screen.\r\n */\r\nfunction Prompt({ message, when = true }) {\r\n  return (\r\n    <RouterContext.Consumer>\r\n      {context => {\r\n        invariant(context, \"You should not use <Prompt> outside a <Router>\");\r\n\r\n        if (!when || context.staticContext) return null;\r\n\r\n        const method = context.history.block;\r\n\r\n        return (\r\n          <Lifecycle\r\n            onMount={self => {\r\n              self.release = method(message);\r\n            }}\r\n            onUpdate={(self, prevProps) => {\r\n              if (prevProps.message !== message) {\r\n                self.release();\r\n                self.release = method(message);\r\n              }\r\n            }}\r\n            onUnmount={self => {\r\n              self.release();\r\n            }}\r\n            message={message}\r\n          />\r\n        );\r\n      }}\r\n    </RouterContext.Consumer>\r\n  );\r\n}\r\n\r\nif (__DEV__) {\r\n  const messageType = PropTypes.oneOfType([PropTypes.func, PropTypes.string]);\r\n\r\n  Prompt.propTypes = {\r\n    when: PropTypes.bool,\r\n    message: messageType.isRequired\r\n  };\r\n}\r\n\r\nexport default Prompt;\r\n","import pathToRegexp from \"path-to-regexp\";\r\n\r\nconst cache = {};\r\nconst cacheLimit = 10000;\r\nlet cacheCount = 0;\r\n\r\nfunction compilePath(path) {\r\n  if (cache[path]) return cache[path];\r\n\r\n  const generator = pathToRegexp.compile(path);\r\n\r\n  if (cacheCount < cacheLimit) {\r\n    cache[path] = generator;\r\n    cacheCount++;\r\n  }\r\n\r\n  return generator;\r\n}\r\n\r\n/**\r\n * Public API for generating a URL pathname from a path and parameters.\r\n */\r\nfunction generatePath(path = \"/\", params = {}) {\r\n  return path === \"/\" ? path : compilePath(path)(params, { pretty: true });\r\n}\r\n\r\nexport default generatePath;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { createLocation, locationsAreEqual } from \"history\";\r\nimport invariant from \"tiny-invariant\";\r\n\r\nimport Lifecycle from \"./Lifecycle\";\r\nimport RouterContext from \"./RouterContext\";\r\nimport generatePath from \"./generatePath\";\r\n\r\n/**\r\n * The public API for navigating programmatically with a component.\r\n */\r\nfunction Redirect({ computedMatch, to, push = false }) {\r\n  return (\r\n    <RouterContext.Consumer>\r\n      {context => {\r\n        invariant(context, \"You should not use <Redirect> outside a <Router>\");\r\n\r\n        const { history, staticContext } = context;\r\n\r\n        const method = push ? history.push : history.replace;\r\n        const location = createLocation(\r\n          computedMatch\r\n            ? typeof to === \"string\"\r\n              ? generatePath(to, computedMatch.params)\r\n              : {\r\n                  ...to,\r\n                  pathname: generatePath(to.pathname, computedMatch.params)\r\n                }\r\n            : to\r\n        );\r\n\r\n        // When rendering in a static context,\r\n        // set the new location immediately.\r\n        if (staticContext) {\r\n          method(location);\r\n          return null;\r\n        }\r\n\r\n        return (\r\n          <Lifecycle\r\n            onMount={() => {\r\n              method(location);\r\n            }}\r\n            onUpdate={(self, prevProps) => {\r\n              const prevLocation = createLocation(prevProps.to);\r\n              if (\r\n                !locationsAreEqual(prevLocation, {\r\n                  ...location,\r\n                  key: prevLocation.key\r\n                })\r\n              ) {\r\n                method(location);\r\n              }\r\n            }}\r\n            to={to}\r\n          />\r\n        );\r\n      }}\r\n    </RouterContext.Consumer>\r\n  );\r\n}\r\n\r\nif (__DEV__) {\r\n  Redirect.propTypes = {\r\n    push: PropTypes.bool,\r\n    from: PropTypes.string,\r\n    to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired\r\n  };\r\n}\r\n\r\nexport default Redirect;\r\n","import pathToRegexp from \"path-to-regexp\";\r\n\r\nconst cache = {};\r\nconst cacheLimit = 10000;\r\nlet cacheCount = 0;\r\n\r\nfunction compilePath(path, options) {\r\n  const cacheKey = `${options.end}${options.strict}${options.sensitive}`;\r\n  const pathCache = cache[cacheKey] || (cache[cacheKey] = {});\r\n\r\n  if (pathCache[path]) return pathCache[path];\r\n\r\n  const keys = [];\r\n  const regexp = pathToRegexp(path, keys, options);\r\n  const result = { regexp, keys };\r\n\r\n  if (cacheCount < cacheLimit) {\r\n    pathCache[path] = result;\r\n    cacheCount++;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Public API for matching a URL pathname to a path.\r\n */\r\nfunction matchPath(pathname, options = {}) {\r\n  if (typeof options === \"string\" || Array.isArray(options)) {\r\n    options = { path: options };\r\n  }\r\n\r\n  const { path, exact = false, strict = false, sensitive = false } = options;\r\n\r\n  const paths = [].concat(path);\r\n\r\n  return paths.reduce((matched, path) => {\r\n    if (!path) return null;\r\n    if (matched) return matched;\r\n\r\n    const { regexp, keys } = compilePath(path, {\r\n      end: exact,\r\n      strict,\r\n      sensitive\r\n    });\r\n    const match = regexp.exec(pathname);\r\n\r\n    if (!match) return null;\r\n\r\n    const [url, ...values] = match;\r\n    const isExact = pathname === url;\r\n\r\n    if (exact && !isExact) return null;\r\n\r\n    return {\r\n      path, // the path used to match\r\n      url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\r\n      isExact, // whether or not we matched exactly\r\n      params: keys.reduce((memo, key, index) => {\r\n        memo[key.name] = values[index];\r\n        return memo;\r\n      }, {})\r\n    };\r\n  }, null);\r\n}\r\n\r\nexport default matchPath;\r\n","import React from \"react\";\r\nimport { isValidElementType } from \"react-is\";\r\nimport PropTypes from \"prop-types\";\r\nimport invariant from \"tiny-invariant\";\r\nimport warning from \"tiny-warning\";\r\n\r\nimport RouterContext from \"./RouterContext\";\r\nimport matchPath from \"./matchPath\";\r\n\r\nfunction isEmptyChildren(children) {\r\n  return React.Children.count(children) === 0;\r\n}\r\n\r\n/**\r\n * The public API for matching a single path and rendering.\r\n */\r\nclass Route extends React.Component {\r\n  render() {\r\n    return (\r\n      <RouterContext.Consumer>\r\n        {context => {\r\n          invariant(context, \"You should not use <Route> outside a <Router>\");\r\n\r\n          const location = this.props.location || context.location;\r\n          const match = this.props.computedMatch\r\n            ? this.props.computedMatch // <Switch> already computed the match for us\r\n            : this.props.path\r\n              ? matchPath(location.pathname, this.props)\r\n              : context.match;\r\n\r\n          const props = { ...context, location, match };\r\n\r\n          let { children, component, render } = this.props;\r\n\r\n          // Preact uses an empty array as children by\r\n          // default, so use null if that's the case.\r\n          if (Array.isArray(children) && children.length === 0) {\r\n            children = null;\r\n          }\r\n\r\n          if (typeof children === \"function\") {\r\n            children = children(props);\r\n\r\n            if (children === undefined) {\r\n              if (__DEV__) {\r\n                const { path } = this.props;\r\n\r\n                warning(\r\n                  false,\r\n                  \"You returned `undefined` from the `children` function of \" +\r\n                    `<Route${path ? ` path=\"${path}\"` : \"\"}>, but you ` +\r\n                    \"should have returned a React element or `null`\"\r\n                );\r\n              }\r\n\r\n              children = null;\r\n            }\r\n          }\r\n\r\n          return (\r\n            <RouterContext.Provider value={props}>\r\n              {children && !isEmptyChildren(children)\r\n                ? children\r\n                : props.match\r\n                  ? component\r\n                    ? React.createElement(component, props)\r\n                    : render\r\n                      ? render(props)\r\n                      : null\r\n                  : null}\r\n            </RouterContext.Provider>\r\n          );\r\n        }}\r\n      </RouterContext.Consumer>\r\n    );\r\n  }\r\n}\r\n\r\nif (__DEV__) {\r\n  Route.propTypes = {\r\n    children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\r\n    component: (props, propName) => {\r\n      if (props[propName] && !isValidElementType(props[propName])) {\r\n        return new Error(\r\n          `Invalid prop 'component' supplied to 'Route': the prop is not a valid React component`\r\n        );\r\n      }\r\n    },\r\n    exact: PropTypes.bool,\r\n    location: PropTypes.object,\r\n    path: PropTypes.oneOfType([\r\n      PropTypes.string,\r\n      PropTypes.arrayOf(PropTypes.string)\r\n    ]),\r\n    render: PropTypes.func,\r\n    sensitive: PropTypes.bool,\r\n    strict: PropTypes.bool\r\n  };\r\n\r\n  Route.prototype.componentDidMount = function() {\r\n    warning(\r\n      !(\r\n        this.props.children &&\r\n        !isEmptyChildren(this.props.children) &&\r\n        this.props.component\r\n      ),\r\n      \"You should not use <Route component> and <Route children> in the same route; <Route component> will be ignored\"\r\n    );\r\n\r\n    warning(\r\n      !(\r\n        this.props.children &&\r\n        !isEmptyChildren(this.props.children) &&\r\n        this.props.render\r\n      ),\r\n      \"You should not use <Route render> and <Route children> in the same route; <Route render> will be ignored\"\r\n    );\r\n\r\n    warning(\r\n      !(this.props.component && this.props.render),\r\n      \"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored\"\r\n    );\r\n  };\r\n\r\n  Route.prototype.componentDidUpdate = function(prevProps) {\r\n    warning(\r\n      !(this.props.location && !prevProps.location),\r\n      '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\r\n    );\r\n\r\n    warning(\r\n      !(!this.props.location && prevProps.location),\r\n      '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\r\n    );\r\n  };\r\n}\r\n\r\nexport default Route;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport { createLocation, createPath } from \"history\";\r\nimport invariant from \"tiny-invariant\";\r\nimport warning from \"tiny-warning\";\r\n\r\nimport Router from \"./Router\";\r\n\r\nfunction addLeadingSlash(path) {\r\n  return path.charAt(0) === \"/\" ? path : \"/\" + path;\r\n}\r\n\r\nfunction addBasename(basename, location) {\r\n  if (!basename) return location;\r\n\r\n  return {\r\n    ...location,\r\n    pathname: addLeadingSlash(basename) + location.pathname\r\n  };\r\n}\r\n\r\nfunction stripBasename(basename, location) {\r\n  if (!basename) return location;\r\n\r\n  const base = addLeadingSlash(basename);\r\n\r\n  if (location.pathname.indexOf(base) !== 0) return location;\r\n\r\n  return {\r\n    ...location,\r\n    pathname: location.pathname.substr(base.length)\r\n  };\r\n}\r\n\r\nfunction createURL(location) {\r\n  return typeof location === \"string\" ? location : createPath(location);\r\n}\r\n\r\nfunction staticHandler(methodName) {\r\n  return () => {\r\n    invariant(false, \"You cannot %s with <StaticRouter>\", methodName);\r\n  };\r\n}\r\n\r\nfunction noop() {}\r\n\r\n/**\r\n * The public top-level API for a \"static\" <Router>, so-called because it\r\n * can't actually change the current location. Instead, it just records\r\n * location changes in a context object. Useful mainly in testing and\r\n * server-rendering scenarios.\r\n */\r\nclass StaticRouter extends React.Component {\r\n  navigateTo(location, action) {\r\n    const { basename = \"\", context = {} } = this.props;\r\n    context.action = action;\r\n    context.location = addBasename(basename, createLocation(location));\r\n    context.url = createURL(context.location);\r\n  }\r\n\r\n  handlePush = location => this.navigateTo(location, \"PUSH\");\r\n  handleReplace = location => this.navigateTo(location, \"REPLACE\");\r\n  handleListen = () => noop;\r\n  handleBlock = () => noop;\r\n\r\n  render() {\r\n    const { basename = \"\", context = {}, location = \"/\", ...rest } = this.props;\r\n\r\n    const history = {\r\n      createHref: path => addLeadingSlash(basename + createURL(path)),\r\n      action: \"POP\",\r\n      location: stripBasename(basename, createLocation(location)),\r\n      push: this.handlePush,\r\n      replace: this.handleReplace,\r\n      go: staticHandler(\"go\"),\r\n      goBack: staticHandler(\"goBack\"),\r\n      goForward: staticHandler(\"goForward\"),\r\n      listen: this.handleListen,\r\n      block: this.handleBlock\r\n    };\r\n\r\n    return <Router {...rest} history={history} staticContext={context} />;\r\n  }\r\n}\r\n\r\nif (__DEV__) {\r\n  StaticRouter.propTypes = {\r\n    basename: PropTypes.string,\r\n    context: PropTypes.object,\r\n    location: PropTypes.oneOfType([PropTypes.string, PropTypes.object])\r\n  };\r\n\r\n  StaticRouter.prototype.componentDidMount = function() {\r\n    warning(\r\n      !this.props.history,\r\n      \"<StaticRouter> ignores the history prop. To use a custom history, \" +\r\n        \"use `import { Router }` instead of `import { StaticRouter as Router }`.\"\r\n    );\r\n  };\r\n}\r\n\r\nexport default StaticRouter;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport invariant from \"tiny-invariant\";\r\nimport warning from \"tiny-warning\";\r\n\r\nimport RouterContext from \"./RouterContext\";\r\nimport matchPath from \"./matchPath\";\r\n\r\n/**\r\n * The public API for rendering the first <Route> that matches.\r\n */\r\nclass Switch extends React.Component {\r\n  render() {\r\n    return (\r\n      <RouterContext.Consumer>\r\n        {context => {\r\n          invariant(context, \"You should not use <Switch> outside a <Router>\");\r\n\r\n          const location = this.props.location || context.location;\r\n\r\n          let element, match;\r\n\r\n          // We use React.Children.forEach instead of React.Children.toArray().find()\r\n          // here because toArray adds keys to all child elements and we do not want\r\n          // to trigger an unmount/remount for two <Route>s that render the same\r\n          // component at different URLs.\r\n          React.Children.forEach(this.props.children, child => {\r\n            if (match == null && React.isValidElement(child)) {\r\n              element = child;\r\n\r\n              const path = child.props.path || child.props.from;\r\n\r\n              match = path\r\n                ? matchPath(location.pathname, { ...child.props, path })\r\n                : context.match;\r\n            }\r\n          });\r\n\r\n          return match\r\n            ? React.cloneElement(element, { location, computedMatch: match })\r\n            : null;\r\n        }}\r\n      </RouterContext.Consumer>\r\n    );\r\n  }\r\n}\r\n\r\nif (__DEV__) {\r\n  Switch.propTypes = {\r\n    children: PropTypes.node,\r\n    location: PropTypes.object\r\n  };\r\n\r\n  Switch.prototype.componentDidUpdate = function(prevProps) {\r\n    warning(\r\n      !(this.props.location && !prevProps.location),\r\n      '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.'\r\n    );\r\n\r\n    warning(\r\n      !(!this.props.location && prevProps.location),\r\n      '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.'\r\n    );\r\n  };\r\n}\r\n\r\nexport default Switch;\r\n","import React from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport RouterContext from \"./RouterContext\";\r\nimport hoistStatics from \"hoist-non-react-statics\";\r\nimport invariant from \"tiny-invariant\";\r\n\r\n/**\r\n * A public higher-order component to access the imperative API\r\n */\r\nfunction withRouter(Component) {\r\n  const displayName = `withRouter(${Component.displayName || Component.name})`;\r\n  const C = props => {\r\n    const { wrappedComponentRef, ...remainingProps } = props;\r\n\r\n    return (\r\n      <RouterContext.Consumer>\r\n        {context => {\r\n          invariant(\r\n            context,\r\n            `You should not use <${displayName} /> outside a <Router>`\r\n          );\r\n          return (\r\n            <Component\r\n              {...remainingProps}\r\n              {...context}\r\n              ref={wrappedComponentRef}\r\n            />\r\n          );\r\n        }}\r\n      </RouterContext.Consumer>\r\n    );\r\n  };\r\n\r\n  C.displayName = displayName;\r\n  C.WrappedComponent = Component;\r\n\r\n  if (__DEV__) {\r\n    C.propTypes = {\r\n      wrappedComponentRef: PropTypes.oneOfType([\r\n        PropTypes.string,\r\n        PropTypes.func,\r\n        PropTypes.object\r\n      ])\r\n    };\r\n  }\r\n\r\n  return hoistStatics(C, Component);\r\n}\r\n\r\nexport default withRouter;\r\n"],"names":["createNamedContext","name","context","createContext","displayName","Router","props","state","location","history","_isMounted","_pendingLocation","staticContext","unlisten","listen","_this","setState","computeRootMatch","pathname","path","url","params","isExact","componentDidMount","this","componentWillUnmount","render","React","RouterContext","Provider","children","value","match","Component","MemoryRouter","createHistory","Lifecycle","onMount","call","componentDidUpdate","prevProps","onUpdate","onUnmount","Prompt","message","when","Consumer","invariant","method","block","self","release","cache","cacheLimit","cacheCount","compilePath","generator","pathToRegexp","compile","generatePath","pretty","Redirect","computedMatch","to","push","replace","createLocation","prevLocation","locationsAreEqual","key","options","cacheKey","end","strict","sensitive","pathCache","keys","result","regexp","matchPath","Array","isArray","exact","concat","reduce","matched","exec","values","memo","index","isEmptyChildren","Children","count","Route","component","length","undefined","createElement","addLeadingSlash","charAt","addBasename","basename","stripBasename","base","indexOf","substr","createURL","createPath","staticHandler","methodName","noop","StaticRouter","handlePush","navigateTo","handleReplace","handleListen","handleBlock","action","rest","createHref","go","goBack","goForward","Switch","element","forEach","child","isValidElement","from","cloneElement","withRouter","C","wrappedComponentRef","remainingProps","ref","WrappedComponent","hoistStatics"],"mappings":"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"}